---
import { Picture } from 'astro:assets';
import { Font } from 'astro:assets';
import collectionData from '../data/games.json';
import AppLayout from '../layouts/AppLayout.astro';
import '../styles/grid.css';

/**
 * TYPE DEFINITIONS BASED ON JSON SCHEMA
 */
interface CollectionItem {
  id?: string;
  label: string;
  url: string;
  igdbId?: number | null;
  // Handle 'oneOf' img vs imageUrl
  imageUrl?: string;
  img?: string;
  categories?: string[];
  featured?: boolean;
  isHighlighted?: boolean;
  // Visual overrides
  width?: string | number;
  height?: string | number;
  objectFit?: 'fill' | 'contain' | 'cover' | 'none' | 'scale-down';
  aspectRatio?: string;
  backgroundColor?: string;
  style?: Record<string, string>;
}

interface Props {
  title?: string;
  description?: string;
  collection?: 'games' | 'apps';
}

const { title = 'Collection', description = 'Browse our collection', collection = 'games' } = Astro.props;

// Safe casting assuming JSON validates against schema
const items = (collectionData[collection] || []) as CollectionItem[];

/**
 * IMAGE IMPORTS
 * Supports raster (PNG, JPG, WebP, AVIF) and vector (SVG) formats
 */
const rasterImports = import.meta.glob<{ default: ImageMetadata }>('../assets/images/**/*.{png,jpg,jpeg,webp,avif}', { eager: true });
const svgImports = import.meta.glob<{ default: any }>('../assets/images/**/*.svg', { eager: true });

const rasterMap = new Map<string, ImageMetadata>();
const svgMap = new Map<string, any>();

for (const [path, module] of Object.entries(rasterImports)) {
  const fileName = path.split('/').pop();
  if (fileName) rasterMap.set(fileName, module.default);
}

for (const [path, module] of Object.entries(svgImports)) {
  const fileName = path.split('/').pop();
  if (fileName) svgMap.set(fileName, module.default);
}

/**
 * HELPER: Parse custom background syntax into valid CSS
 */
const parseBackground = (bg?: string): string | undefined => {
  if (!bg) return undefined;

  // Format: "COLORS | DIRECTION"
  const [colorDef, directionDef] = bg.split('|').map((s) => s.trim());
  const direction = directionDef || 'to bottom right';

  const raw = colorDef;
  const upper = raw.toUpperCase();

  // Handle RGB Gradient: "RGB: 4 4 5 > 24 57 73"
  if (upper.startsWith('RGB:') && upper.includes('>')) {
    const colors = raw
      .slice(4)
      .split('>')
      .map((part) => {
        const numbers = part.trim().split(/\s+/).join(',');
        return `rgb(${numbers})`;
      });
    return `linear-gradient(${direction}, ${colors[0]}, ${colors[1]})`;
  }

  // Handle HEX Gradient: "HEX: #040405 > #183949"
  if (upper.startsWith('HEX:') && upper.includes('>')) {
    const colors = raw
      .slice(4)
      .split('>')
      .map((c) => c.trim());
    return `linear-gradient(${direction}, ${colors[0]}, ${colors[1]})`;
  }

  // Fallback: return raw string
  return bg;
};
---

<AppLayout title={title} description={description}>
  <Fragment slot="head">
    <Font cssVariable="--font-poppins" />
  </Fragment>

  <div class="bg-effects"></div>

  <Fragment slot="header">
    <button class="random-btn" id="randomItemBtn">
      Random {collection.slice(0, -1).replace(/^\w/, (c) => c.toUpperCase())}
    </button>

    <search>
      <input
        list="datalist-items"
        type="text"
        id="search-input"
        placeholder={`Search for YOUR Favorite ${collection.slice(0, -1)}...`}
        autocomplete="on"
        aria-label="On this page"
      />
    </search>

    <datalist id="datalist-items">
      {items.map((item) => <option value={item.label} />)}
    </datalist>

    <div class="filter-container"></div>
  </Fragment>

  <section class="collection-container" id="imageContainer">
    {
      items.map((item) => {
        // 1. Normalize Image Source (Schema allows 'img' or 'imageUrl')
        const rawImg = item.img || item.imageUrl || '';
        const fileName = rawImg ? rawImg.split('/').pop() : '';
        const isHttpUrl = rawImg && (rawImg.startsWith('http://') || rawImg.startsWith('https://'));

        // 2. Resolve Categories
        const mainCategory = item.categories?.[0]?.toLowerCase() || '';

        // 3. Resolve Styling
        const bgParsed = parseBackground(item.backgroundColor);

        // Merge arbitrary 'style' object with the parsed background
        const cardStyles = {
          ...(item.style || {}),
          ...(bgParsed ? { background: bgParsed } : {})
        };

        // 4. Resolve Dimensions & Object Fit
        // Default to 100% dimensions via CSS if not specified
        const cssWidth = item.width ? (typeof item.width === 'number' ? `${item.width}px` : item.width) : '100%';
        const cssHeight = item.height ? (typeof item.height === 'number' ? `${item.height}px` : item.height) : '100%';
        const objectFit = item.objectFit || 'cover';
        const aspectRatio = item.aspectRatio || 'auto';

        // 5. Check for local assets
        const localRaster = fileName ? rasterMap.get(fileName) : undefined;
        const SvgComponent = fileName ? svgMap.get(fileName) : undefined;

        // Common styles applied to the image/SVG element
        const imgStyle = {
          width: cssWidth,
          height: cssHeight,
          objectFit: objectFit,
          aspectRatio: aspectRatio
        };

        return (
          <figure class="collection-card" data-label={item.label} data-category={mainCategory} data-url={item.url}>
            <a href={`/play?url=${encodeURIComponent(item.url)}`} aria-label={`Open ${item.label}`} style={cardStyles}>
              {/* SVG Component (Local) */}
              {SvgComponent && (
                <div
                  class="svg-wrapper"
                  style={{
                    display: 'flex',
                    justifyContent: 'center',
                    alignItems: 'center',
                    width: '100%',
                    height: '100%'
                  }}
                >
                  <SvgComponent
                    width={typeof item.width === 'number' ? item.width : 200}
                    height={typeof item.height === 'number' ? item.height : 170}
                    style={imgStyle}
                    aria-label={item.label}
                  />
                </div>
              )}

              {/* Local Raster Image */}
              {localRaster && !SvgComponent && (
                <Picture
                  src={localRaster}
                  width={200}
                  height={170}
                  alt={item.label}
                  loading="lazy"
                  fetchpriority="auto"
                  decoding="async"
                  data-auto-detect
                  formats={['avif', 'webp', 'png']}
                  style={imgStyle}
                />
              )}

              {/* Remote Image */}
              {!localRaster && !SvgComponent && isHttpUrl && (
                <Picture
                  src={rawImg}
                  width={200}
                  height={170}
                  alt={item.label}
                  loading="lazy"
                  fetchpriority="auto"
                  decoding="async"
                  data-auto-detect
                  formats={['avif', 'webp', 'png']}
                  style={imgStyle}
                />
              )}

              {/* Fallback: No Image */}
              {!localRaster && !SvgComponent && !isHttpUrl && (
                <div style="width: 100%; height: 100%; min-height: 170px; background: #333; display: flex; align-items: center; justify-content: center;">
                  <span>No Image</span>
                </div>
              )}
            </a>

            <figcaption class="label">{item.label}</figcaption>
          </figure>
        );
      })
    }
  </section>

  <style>
    .collection-card a {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      overflow: hidden;
      border-radius: inherit;
    }
  </style>

  <script is:inline>
    document.addEventListener('DOMContentLoaded', () => {
      const searchInput = document.getElementById('search-input');
      const randomBtn = document.getElementById('randomItemBtn');
      const allCards = Array.from(document.querySelectorAll('.collection-card'));

      /* -----------------------------
         AUTO-DETECT ABOVE THE FOLD
      ------------------------------ */
      const autoImages = document.querySelectorAll('img[data-auto-detect]');

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.loading = 'eager';
            img.fetchPriority = 'high';
            img.decoding = 'auto';
            observer.unobserve(img);
          }
        });
      });

      autoImages.forEach((img) => observer.observe(img));

      /* -----------------------------
         FILTER LOGIC
      ------------------------------ */
      function filterItems() {
        const searchTerm = searchInput.value.toLowerCase();

        allCards.forEach((card) => {
          const label = card.getAttribute('data-label').toLowerCase();
          const matchesSearch = label.includes(searchTerm);
          card.style.display = matchesSearch ? '' : 'none';
        });
      }

      randomBtn.addEventListener('click', () => {
        if (allCards.length > 0) {
          const randomIndex = Math.floor(Math.random() * allCards.length);
          const link = allCards[randomIndex].querySelector('a');
          if (link) window.location.href = link.href;
        }
      });

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      if (searchInput) {
        searchInput.addEventListener('input', debounce(filterItems, 300));
      }
    });
  </script>
</AppLayout>
