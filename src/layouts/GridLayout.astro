---
import { Picture } from 'astro:assets';
import { Font } from 'astro:assets';
import collectionData from '../data/games.json';
import AppLayout from '../layouts/AppLayout.astro';
import '../styles/grid.css';

interface Props {
  title?: string;
  description?: string;
  collection?: 'games' | 'apps';
  hasCategories?: boolean;
}

const { title = 'Collection', description = 'Browse our collection', collection = 'games' } = Astro.props;
let { hasCategories } = Astro.props;

const items = collectionData[collection] || [];
hasCategories ??= false;

/**
 * Image imports
 */
const rasterImports = import.meta.glob<{ default: ImageMetadata }>('../assets/images/**/*.{png,jpg,jpeg,webp,avif}', { eager: true });
const svgImports = import.meta.glob<{ default: any }>('../assets/images/**/*.svg', { eager: true });

const rasterMap = new Map<string, ImageMetadata>();
const svgMap = new Map<string, any>();

for (const [path, module] of Object.entries(rasterImports)) {
  const fileName = path.split('/').pop();
  if (fileName) rasterMap.set(fileName, module.default);
}

for (const [path, module] of Object.entries(svgImports)) {
  const fileName = path.split('/').pop();
  if (fileName) svgMap.set(fileName, module.default);
}

/**
 * Helper: Parses custom background syntax into valid CSS
 * * SYNTAX EXAMPLES:
 * 1. Default (to bottom right): "HEX: #000000 > #ffffff"
 * 2. With Direction:            "HEX: #000000 > #ffffff | to top"
 * 3. With Angle:                "RGB: 0 0 0 > 255 255 255 | 90deg"
 */
const parseBackground = (bg?: string) => {
  if (!bg) return undefined;

  // 1. Split color definition from optional direction
  // Format: "COLORS | DIRECTION"
  const [colorDef, directionDef] = bg.split('|').map((s) => s.trim());

  // Default to 'to bottom right' if no direction is specified
  const direction = directionDef || 'to bottom right';

  const raw = colorDef;
  const upper = raw.toUpperCase();

  // Handle RGB Gradient: "RGB: 4 4 5 > 24 57 73"
  if (upper.startsWith('RGB:') && upper.includes('>')) {
    const colors = raw
      .slice(4)
      .split('>')
      .map((part) => {
        // Convert "4 4 5" -> "rgb(4,4,5)"
        const numbers = part.trim().split(/\s+/).join(',');
        return `rgb(${numbers})`;
      });
    return `linear-gradient(${direction}, ${colors[0]}, ${colors[1]})`;
  }

  // Handle HEX Gradient: "HEX: #040405 > #183949"
  if (upper.startsWith('HEX:') && upper.includes('>')) {
    const colors = raw
      .slice(4)
      .split('>')
      .map((c) => c.trim());
    return `linear-gradient(${direction}, ${colors[0]}, ${colors[1]})`;
  }

  // Fallback: return raw string (allows standard CSS values like "red" or "var(--my-color)")
  return bg;
};
---

<AppLayout title={title} description={description}>
  <Fragment slot="head">
    <Font cssVariable="--font-poppins" />
  </Fragment>

  <div class="bg-effects"></div>

  <Fragment slot="header">
    <button class="random-btn" id="randomItemBtn">
      Random {collection.slice(0, -1).replace(/^\w/, (c) => c.toUpperCase())}
    </button>

    <search>
      <input
        list="datalist-items"
        type="text"
        id="search-input"
        placeholder={`Search for YOUR Favorite ${collection.slice(0, -1)}...`}
        autocomplete="on"
        aria-label="On this page"
      />
    </search>

    <datalist id="datalist-items">
      {items.map((item: any) => <option value={item.label} />)}
    </datalist>

    <div class="filter-container"></div>
  </Fragment>

  <section class="collection-container" id="imageContainer">
    {
      items.map((item: any) => {
        const imageUrl = item.img || item.imageUrl || '';
        const fileName = imageUrl ? imageUrl.split('/').pop() : '';
        const isHttpUrl = imageUrl && (imageUrl.startsWith('http://') || imageUrl.startsWith('https://'));
        const mainCategory = item.categories?.[0]?.toLowerCase() || '';

        // Parse background with new direction logic
        const finalBackground = parseBackground(item.svgBackground);

        const localRaster = fileName ? rasterMap.get(fileName) : undefined;
        const SvgComponent = fileName ? svgMap.get(fileName) : undefined;

        return (
          <figure class="collection-card" data-label={item.label} data-category={mainCategory} data-url={item.url}>
            <a
              href={`/play?url=${encodeURIComponent(item.url)}`}
              aria-label={`Open ${item.label}`}
              style={finalBackground ? `background: ${finalBackground};` : undefined}
            >
              {/* SVG */}
              {SvgComponent && (
                <div
                  class="svg-wrapper"
                  style="width: 100%; height: 100%; min-height: 170px; display: flex; justify-content: center; align-items: center;"
                >
                  <SvgComponent width='95%' height='95%'' aria-label={item.label} />
                </div>
              )}

              {/* Local Image */}
              {localRaster && !SvgComponent && (
                <Picture
                  src={localRaster}
                  width={200}
                  height={170}
                  alt={item.label}
                  loading="lazy"
                  fetchpriority="auto"
                  decoding="async"
                  data-auto-detect
                  formats={['avif', 'webp', 'png']}
                  style="width: 100%; height: 100%; object-fit: cover;"
                />
              )}

              {/* Remote Image */}
              {!localRaster && !SvgComponent && isHttpUrl && (
                <Picture
                  src={imageUrl}
                  width={200}
                  height={170}
                  alt={item.label}
                  loading="lazy"
                  fetchpriority="auto"
                  decoding="async"
                  data-auto-detect
                  formats={['avif', 'webp', 'png']}
                  style="width: 100%; height: 100%; object-fit: cover;"
                />
              )}

              {/* CASE 4: No Image Found */}
              {!localRaster && !SvgComponent && !isHttpUrl && (
                <div style="width: 100%; height: 100%; min-height: 170px; background: #333; display: flex; align-items: center; justify-content: center;">
                  <span>No Image</span>
                </div>
              )}
            </a>

            <figcaption class="label">{item.label}</figcaption>
          </figure>
        );
      })
    }
  </section>

  <style>
    .collection-card a {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      overflow: hidden;
      border-radius: inherit;
    }
  </style>

  <script is:inline>
    document.addEventListener('DOMContentLoaded', () => {
      const searchInput = document.getElementById('search-input');
      const randomBtn = document.getElementById('randomItemBtn');
      const allCards = Array.from(document.querySelectorAll('.collection-card'));

      /* -----------------------------
         AUTO-DETECT ABOVE THE FOLD
      ------------------------------ */
      const autoImages = document.querySelectorAll('img[data-auto-detect]');

      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.loading = 'eager';
            img.fetchPriority = 'high';
            img.decoding = 'auto';
            observer.unobserve(img);
          }
        });
      });

      autoImages.forEach((img) => observer.observe(img));

      /* -----------------------------
         FILTER LOGIC
      ------------------------------ */
      function filterItems() {
        const searchTerm = searchInput.value.toLowerCase();

        allCards.forEach((card) => {
          const label = card.getAttribute('data-label').toLowerCase();
          const matchesSearch = label.includes(searchTerm);
          card.style.display = matchesSearch ? '' : 'none';
        });
      }

      randomBtn.addEventListener('click', () => {
        if (allCards.length > 0) {
          const randomIndex = Math.floor(Math.random() * allCards.length);
          const link = allCards[randomIndex].querySelector('a');
          if (link) window.location.href = link.href;
        }
      });

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }

      if (searchInput) {
        searchInput.addEventListener('input', debounce(filterItems, 300));
      }
    });
  </script>
</AppLayout>
