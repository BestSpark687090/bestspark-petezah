---
import controllerUrl from '@petezah-games/scramjet-controller?url';
import scramjetUrl from '@mercuryworkshop/scramjet?url';
import AppLayout from '../../layouts/AppLayout.astro';

const { target } = Astro.params;
let computedURL: string;

let cachedList: Set<string> | null = null;
let cachedAt = 0;
const CACHE_DURATION = 2 * 60 * 60 * 1000;

async function getBlockedDomains() {
  const now = Date.now();
  if (cachedList && now - cachedAt < CACHE_DURATION) return cachedList;

  try {
    const response = await fetch('https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/gambling-porn/hosts');
    const text = await response.text();
    const domains = new Set<string>();

    for (const line of text.split('\n')) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      const parts = trimmed.split(/\s+/);
      if (parts.length >= 2 && (parts[0] === '0.0.0.0' || parts[0] === '127.0.0.1')) {
        domains.add(parts[1].toLowerCase());
      }
    }
    cachedList = domains;
    cachedAt = now;
    return domains;
  } catch (e) {
    console.error('Failed to fetch blocklist', e);
    return new Set<string>(); // Fail open if list is down
  }
}

try {
  if (!target) throw new Error('No target specified');

  const decoded = decodeURIComponent(target);
  const parsed = new URL(decoded);

  if (!['http:', 'https:'].includes(parsed.protocol)) {
    throw new Error('Invalid protocol');
  }

  // Check Blocklist
  const blocked = await getBlockedDomains();
  if (blocked.has(parsed.hostname)) {
    return Astro.redirect('/blocked');
  }

  computedURL = parsed.toString();
} catch {
  return Astro.redirect('/404');
}

// Configuration for Client
const scramjetConfig = {
  controllerUrl,
  scramjetUrl, // This acts as the initPath
  wispUrl: 'ws://localhost:4501/',
  scope: '/petezah/scram/',
  swPath: '../../scripts/SJsw.ts'
};
---

<AppLayout title="Scramjet Embed" description={`Embedded Site for ${computedURL}`}>
  <div id="status-container">
    <h1 id="status">Initializing...</h1>
  </div>

  <iframe id="embedFrame" style="width: 100%; height: 100%; border: none;" data-url={computedURL} data-config={JSON.stringify(scramjetConfig)}
  ></iframe>

  <script>
    import libcurlPKG from '@mercuryworkshop/libcurl-transport';
    import { Controller, config } from '@petezah-games/scramjet-controller';

    const { LibcurlClient } = libcurlPKG as any;
    const computedURL = document.getElementById('embedFrame')?.dataset.url;
    async function main(): Promise<void> {
      const frameEl = document.querySelector<HTMLIFrameElement>('#embedFrame');
      const statusEl = document.getElementById('status') as HTMLElement | null;
      if (!frameEl || !statusEl || !frameEl.dataset.config) {
        console.error('Required elements missing');
        return;
      }
      let cfg: any;
      // Parse config passed from frontmatter
      try {
        cfg = JSON.parse(frameEl.dataset.config);
      } catch (e) {
        if (statusEl) statusEl.textContent = 'Error: Invalid configuration';
        console.error('Config parse error', e);
        return;
      }

      // Setup Scramjet Global Config
      config.prefix = cfg.scope;
      config.wasmPath = `${cfg.scramjetUrl}scramjet.wasm`;
      config.scramjetPath = cfg.scramjetUrl;

      // 1. Register Service Worker
      if (statusEl) statusEl.textContent = 'Registering service worker...';

      try {
        const registration = await navigator.serviceWorker.register(cfg.swPath, {
          scope: cfg.scope,
          type: 'module' // Ensure your SW integration outputs ESM
        });

        // 2. Wait for Activation
        if (!navigator.serviceWorker.controller) {
          if (statusEl) statusEl.textContent = 'Waiting for service worker to activate...';

          await new Promise<void>((resolve): void => {
            if (registration.active) {
              resolve();
            } else {
              const sw = registration.installing || registration.waiting;
              if (sw) {
                sw.addEventListener('statechange', (e: Event): void => {
                  const target = e.target as ServiceWorker | null;
                  if (target && target.state === 'activated') resolve();
                });
              }
            }
          });

          // Force claim implies we usually don't need a reload if the SW claims immediately
          // but we wait for controller change to be safe
          if (!navigator.serviceWorker.controller) {
            await new Promise<void>((resolve): void => navigator.serviceWorker.addEventListener('controllerchange', () => resolve(), { once: true }));
          }
        }

        if (statusEl) statusEl.textContent = 'Initializing controller...';

        // 3. Initialize Transport and Controller
        const transport = new LibcurlClient({ wisp: cfg.wispUrl });
        const activeServiceWorker = registration.active;
        if (!activeServiceWorker) {
          throw new Error('Service worker failed to activate');
        }
        const controller = new Controller({
          serviceworker: activeServiceWorker as ServiceWorker,
          transport
        });

        // 4. Start Scramjet
        controller.wait;
        const frame = controller.createFrame(frameEl);

        if (statusEl) statusEl.textContent = ''; // Clear status on success
        const statusContainer = document.getElementById('status-container') as HTMLElement | null;
        if (statusContainer) statusContainer.style.display = 'none';

        // 5. Navigate
        if (computedURL) {
          frame.go(computedURL);
        }
      } catch (err: unknown) {
        const errMsg = err instanceof Error ? err.message : String(err);
        if (statusEl) statusEl.textContent = `Error: ${errMsg}`;
        console.error('Scramjet Init Error:', err);
      }
    }

    // Run main
    main();
  </script>
</AppLayout>
