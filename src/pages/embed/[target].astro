---
// Define Packages to pass to client
import libcurlpkg from '@mercuryworkshop/libcurl-transport';
const { LibcurlClient } = libcurlpkg
import Epoxypkg from '@mercuryworkshop/epoxy-transport';
const { EpoxyClient }= Epoxypkg
import { Controller, config } from "@petezah-games/scramjet-controller";
// End Defined Packages
export const prerender = false;
import AppLayout from '../../layouts/AppLayout.astro';
const { target } = Astro.params;
let computedURL;

/* Filter for bad domains */
// Cache
let cachedList: Set<string> | null = null;
let cachedAt = 0;

// 2 hours in milliseconds
const CACHE_DURATION = 2 * 60 * 60 * 1000;

async function getBlockedDomains() {
  const now = Date.now();

  if (cachedList && now - cachedAt < CACHE_DURATION) {
    return cachedList;
  }

  // Fetch the hosts file
  const response = await fetch('https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/gambling-porn/hosts');
  const text = await response.text();

  // Parse into a Set of domains
  const domains: Set<string> = new Set();

  for (const line of text.split('\n')) {
    const trimmed = line.trim();

    // Skip comments and empty lines
    if (!trimmed || trimmed.startsWith('#')) continue;

    const parts = trimmed.split(/\s+/);
    if (parts.length < 2) continue;

    const [ip, domain] = parts;

    // Only accept 0.0.0.0 or 127.0.0.1 entries
    if (ip === '0.0.0.0' || ip === '127.0.0.1') {
      domains.add(domain.toLowerCase());
    }
  }

  // Cache it
  cachedList = domains;
  cachedAt = now;

  return domains;
}

try {
  const decoded = decodeURIComponent(target);
  const parsed = new URL(decoded);
  if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
    throw new Error('Invalid protocol');
  }
  computedURL = parsed.toString();
} catch {
  Astro.redirect('/404');
}
---

<AppLayout title="Scramjet Embed" description=`Embedded Site for ${computedURL}`>
  <div id="status">Initializing...</div>
  <iframe
    id="embedFrame"
    style="width: 100%; height: 100%"
    data-libcurl={LibcurlClient}
    data-epoxy={EpoxyClient}
    data-scram-controller-config={JSON.stringify( config )}
    data-scram-controller-main={Controller}></iframe>
  <script src="/scram/scramjet.js" is:inline></script>
  <script src="/scramcontroller/controller.api.js" is:inline></script>
  <script type="module" is:inline>
    // @ts-check
    const embedFrame = document.getElementById("embedFrame")
    const config = JSON.parse((embedFrame.dataset.scramControllerConfig).replace(/&#34;/g, '"'));
    const LibcurlClient = embedFrame?.dataset.libcurl
    const EpoxyClient = embedFrame?.dataset.epoxy
    const Controller = embedFrame?.dataset.ControllerMain

    config.prefix = "/petezah/scram/"
		config.wasmPath = "/scram/scramjet.wasm";
		config.injectPath = "/scramcontroller/controller.inject.js";
		config.wasmPath = "/scram/scramjet.wasm";
		config.scramjetPath = "/scram/scramjet.js";
    const statusEl = document.getElementById('status');
    let scramjetFrame;
    async function init() {
      statusEl.textContent = 'Registering service worker...';
      const registration = await navigator.serviceWorker.register('/petezah/SJsw.js', { type: 'module', scope: '/petezah/scram' });
      // Wait for the service worker to be ready
      if (!navigator.serviceWorker.controller) {
        statusEl.textContent = 'Waiting for service worker to activate...';
        await new Promise((resolve) => {
          if (registration.active) {
            resolve();
            return;
          }
          const sw = registration.installing || registration.waiting;
          if (sw) {
            sw.addEventListener('statechange', () => {
              if (sw.state === 'activated') resolve();
            });
          }
        });
        // Wait for controller
        if (!navigator.serviceWorker.controller) {
          await new Promise((resolve) => {
            navigator.serviceWorker.addEventListener('controllerchange', resolve, { once: true });
          });
        }
      }
      statusEl.textContent = 'Initializing controller...';
      const transport = new LibcurlClient({
        wisp: 'ws://localhost:4501/'
      });

      controller = new Controller({
        serviceworker: registration.active,
        transport
      });

      await controller.wait;

      scramjetFrame = controller.createFrame(embedFrame);
      scramjetFrame.go('about:blank');
    }

    init().catch((err) => {
      statusEl.textContent = `Error: ${err.message}`;
      console.error('Harness init error:', err);
    });
  </script>
</AppLayout>
