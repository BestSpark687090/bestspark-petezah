<script>
  // --- General Page Load ---
  document.addEventListener('DOMContentLoaded', (): void => {
    setTimeout((): void => {
      document.body.classList.add('loaded');
    }, 1000);
  });

  // --- INFINITE CAROUSEL LOGIC ---
  const carouselTrack = document.querySelector<HTMLElement>('.carousel-track');
  // Select all ORIGINAL items immediately (before cloning)
  const originalItems = document.querySelectorAll<HTMLElement>('.carousel-item');
  const carouselDots = document.getElementById('carouselDots');

  let itemsPerView: number = 1;
  let carouselIndex: number = 0; // The visual index (including clones)
  let logicalIndex: number = 0; // The actual data index (0 to total-1)
  let isTransitioning: boolean = false;
  let slideWidth: number = 0;
  let totalOriginal: number = originalItems.length;

  // Touch variables
  let touchStartX: number = 0;
  let touchEndX: number = 0;
  let isDragging: boolean = false;

  function initCarousel(): void {
    if (!carouselTrack || originalItems.length === 0) return;

    // 1. Calculate dimensions
    const container = document.querySelector('.carousel-container') as HTMLElement | null;
    const gap = 8; // CSS gap
    const containerWidth = container?.clientWidth || 0;
    // Measure one item to determine how many fit
    const sampleItem = originalItems[0] as HTMLElement | undefined;
    const itemWidth = sampleItem?.offsetWidth || 0;

    slideWidth = itemWidth + gap;
    itemsPerView = Math.floor(containerWidth / slideWidth);
    if (itemsPerView < 1) itemsPerView = 1;

    // 2. Clear existing track to prevent duplicate clones on resize
    carouselTrack.innerHTML = '';

    // 3. Create Clones
    // We clone 'itemsPerView' amount of items for both ends to ensure no whitespace during transition
    const fragment = document.createDocumentFragment();

    // Prepend clones (Last 'n' items)
    for (let i = totalOriginal - itemsPerView; i < totalOriginal; i++) {
      let idx = (i + totalOriginal) % totalOriginal; // Handle negative wrap safety
      let clone = originalItems[idx].cloneNode(true) as HTMLElement;
      clone.classList.add('clone');
      fragment.appendChild(clone);
    }

    // Add Original Items
    originalItems.forEach((item) => fragment.appendChild(item));

    // Append clones (First 'n' items)
    for (let i = 0; i < itemsPerView; i++) {
      let clone = originalItems[i].cloneNode(true) as HTMLElement;
      clone.classList.add('clone');
      fragment.appendChild(clone);
    }

    if (carouselTrack) {
      carouselTrack.appendChild(fragment);
    }

    // 4. Set Initial Position (Skip the first set of clones)
    carouselIndex = itemsPerView;
    updateTrackPosition(false); // false = no animation
    updateCarouselDots();
  }

  function updateTrackPosition(animate: boolean = true): void {
    if (!carouselTrack) return;
    const track = carouselTrack as HTMLElement;
    if (animate) {
      track.style.transition = 'transform 0.3s ease-in-out';
    } else {
      track.style.transition = 'none';
    }
    track.style.transform = `translateX(-${carouselIndex * slideWidth}px)`;
  }

  function moveCarousel(direction: number): void {
    if (isTransitioning) return;
    isTransitioning = true;

    carouselIndex += direction;

    // Calculate logical index for dots
    if (direction === 1) {
      logicalIndex++;
      if (logicalIndex >= totalOriginal) logicalIndex = 0;
    } else {
      logicalIndex--;
      if (logicalIndex < 0) logicalIndex = totalOriginal - 1;
    }

    updateTrackPosition(true);
    updateCarouselDots();
  }

  // Handle the "Loop" when transition finishes
  carouselTrack?.addEventListener('transitionend', () => {
    isTransitioning = false;

    // If we scrolled past the last real item (into appended clones)
    if (carouselIndex >= totalOriginal + itemsPerView) {
      carouselIndex = itemsPerView; // Snap to start
      updateTrackPosition(false);
    }
    // If we scrolled before the first real item (into prepended clones)
    else if (carouselIndex < itemsPerView) {
      carouselIndex = totalOriginal + itemsPerView - 1; // Snap to end
      updateTrackPosition(false);
    }
  });

  function updateCarouselDots() {
    if (!carouselDots) return;
    // Ensure logical index is always safe
    let activeDot = logicalIndex;

    // Generate dots based on TOTAL ORIGINAL items (minus those that don't need a scroll if desired, but usually 1 dot per item for infinite)
    const dotsHtml = Array.from(
      { length: totalOriginal },
      (_, i) => `<div class="carousel-dot ${i === activeDot ? 'active' : ''}" onclick="goToCarouselSlide(${i})"></div>`
    ).join('');

    carouselDots.innerHTML = dotsHtml;
  }

  (window as any).goToCarouselSlide = function (index: number): void {
    // Make global for onclick
    if (isTransitioning) return;
    logicalIndex = index;
    carouselIndex = index + itemsPerView; // Add offset for clones
    updateTrackPosition(true);
    updateCarouselDots();
  };

  // --- Touch / Swipe Logic ---
  function handleTouchStart(e: TouchEvent): void {
    touchStartX = e.touches[0].clientX;
    isDragging = true;
  }
  function handleTouchMove(e: TouchEvent): void {
    if (!isDragging) return;
    touchEndX = e.touches[0].clientX;
  }
  function handleTouchEnd(): void {
    if (!isDragging) return;
    isDragging = false;
    handleSwipe();
  }
  function handleMouseDown(e: MouseEvent): void {
    touchStartX = e.clientX;
    isDragging = true;
  }
  function handleMouseMove(e: MouseEvent): void {
    if (!isDragging) return;
    touchEndX = e.clientX;
  }
  function handleMouseUp(): void {
    isDragging = false;
    handleSwipe();
  }

  function handleSwipe(): void {
    const swipeThreshold = 50;
    const swipeDistance = touchStartX - touchEndX;
    if (Math.abs(swipeDistance) > swipeThreshold) {
      if (swipeDistance > 0) {
        moveCarousel(1); // Next
      } else {
        moveCarousel(-1); // Prev
      }
    }
  }

  // Initialize Carousel
  document.addEventListener('DOMContentLoaded', (): void => {
    initCarousel();

    // Event Listeners
    if (carouselTrack) {
      carouselTrack.addEventListener('touchstart', handleTouchStart, { passive: true });
      carouselTrack.addEventListener('touchmove', handleTouchMove, { passive: false });
      carouselTrack.addEventListener('touchend', handleTouchEnd, { passive: true });
      carouselTrack.addEventListener('mousedown', handleMouseDown);
      carouselTrack.addEventListener('mousemove', handleMouseMove);
      carouselTrack.addEventListener('mouseup', handleMouseUp);
      carouselTrack.addEventListener('mouseleave', handleMouseUp);
    }
  });

  // Handle Resize
  (window as any).resizeTimer = null;
  window.addEventListener('resize', (): void => {
    clearTimeout((window as any).resizeTimer);
    (window as any).resizeTimer = setTimeout((): void => {
      // Reset to original state to recalculate properly
      initCarousel();
    }, 200);
  });

  // --- REST OF THE UTILITIES (Typewriter, Battery, etc) ---

  // Image Caption Rotator
  const images = [
    { src: '/storage/images/main/highway-racer.jpeg', caption: 'Highway Racer' },
    { src: '/storage/images/main/buildnow.jpeg', caption: 'Buildnow.gg' },
    { src: '/storage/ag/g/slope/IMG_5256.jpeg', caption: 'Slope' },
    { src: '/storage/images/main/clash.jpeg', caption: 'Clash Royale' },
    { src: '/storage/images/main/superstarcar.jpeg', caption: 'Superstar Car' },
    { src: '/storage/ag/g/yohoho/IMG_5302.jpeg', caption: 'YoHoHo!' }
  ];

  let currentImgIndex: number = 0;
  const imageElement = document.getElementById('large-image') as HTMLImageElement | null;
  const captionElement = document.getElementById('large-image-caption') as HTMLElement | null;

  if (imageElement && captionElement) {
    const imgEl = imageElement as HTMLImageElement;
    const captionEl = captionElement as HTMLElement;

    function changeImage(): void {
      currentImgIndex = (currentImgIndex + 1) % images.length;
      const currentImage = images[currentImgIndex];
      imgEl.src = currentImage.src;
      captionEl.textContent = currentImage.caption;
    }
    setInterval(changeImage, 3000);
  }

  // Typewriter Effect
  class TxtType {
    el: HTMLElement;
    toRotate: string[];
    loopNum: number;
    period: number;
    txt: string;
    isDeleting: boolean;

    constructor(el: HTMLElement, toRotate: string[], period: number | string) {
      this.toRotate = toRotate;
      this.el = el;
      this.loopNum = 0;
      this.period = parseInt(period.toString(), 10) || 2000;
      this.txt = '';
      this.isDeleting = false;
      this.tick();
    }

    tick(): void {
      const i = this.loopNum % this.toRotate.length;
      const fullTxt = this.toRotate[i];

      if (this.isDeleting) {
        this.txt = fullTxt.substring(0, this.txt.length - 1);
      } else {
        this.txt = fullTxt.substring(0, this.txt.length + 1);
      }

      this.el.innerHTML = '<span class="wrap">' + this.txt + '</span>';

      let delta: number = 200 - Math.random() * 100;

      if (this.isDeleting) {
        delta /= 2;
      }

      if (!this.isDeleting && this.txt === fullTxt) {
        delta = this.period;
        this.isDeleting = true;
      } else if (this.isDeleting && this.txt === '') {
        this.isDeleting = false;
        this.loopNum++;
        delta = 500;
      }

      setTimeout((): void => this.tick(), delta);
    }
  }

  document.addEventListener('DOMContentLoaded', (): void => {
    const elements = document.getElementsByClassName('typewrite');
    for (let i = 0; i < elements.length; i++) {
      const toRotate = elements[i].getAttribute('data-type');
      const period = elements[i].getAttribute('data-period');
      if (toRotate) {
        new TxtType(elements[i] as HTMLElement, JSON.parse(toRotate), period || '2000');
      }
    }
    const css = document.createElement('style');
    (css as any).type = 'text/css';
    css.innerHTML = '.typewrite > .wrap { border-right: 0.06em solid #0096FF}';
    document.body.appendChild(css);
  });

  // Popup Logic
  document.addEventListener('DOMContentLoaded', (): void => {
    const popup = document.getElementById('discord-popup') as HTMLElement | null;
    const closeBtn = document.getElementById('close-popup') as HTMLElement | null;

    if (popup && closeBtn) {
      function checkPopup(): void {
        const lastPopupClose = localStorage.getItem('lastPopupClose');
        const currentTime = new Date().getTime();
        const lastClose = lastPopupClose ? parseInt(lastPopupClose, 10) : 0;
        if (!lastPopupClose || currentTime - lastClose > 3600000) {
          (popup as HTMLElement).style.display = 'flex';
        }
      }
      closeBtn.addEventListener('click', (): void => {
        popup.style.display = 'none';
        localStorage.setItem('lastPopupClose', new Date().getTime().toString());
      });
      checkPopup();
    }
  });

  // System Stats (Time, Battery, FPS)
  document.addEventListener('DOMContentLoaded', (): void => {
    const timeDisplay = document.getElementById('time-display') as HTMLElement | null;
    const batteryIcon = document.getElementById('battery-icon') as HTMLElement | null;
    const batteryPercentage = document.getElementById('battery-percentage') as HTMLElement | null;
    const fpsElement = document.getElementById('fps') as HTMLElement | null;

    let frameCount: number = 0;
    let lastUpdateTime: number = performance.now();

    function updateTime(): void {
      if (!timeDisplay) return;
      const now = new Date();
      const timeString = now.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
      });
      timeDisplay.textContent = ` ${timeString}`;
    }

    function updateBattery(): void {
      if (!batteryPercentage || !batteryIcon) return;
      if ('getBattery' in navigator) {
        (navigator as any).getBattery().then((battery: any) => {
          const level = battery.level * 100;
          const percentage = Math.round(level);

          batteryPercentage.textContent = `${percentage}%`;

          batteryIcon.className = 'fas battery-icon';
          if (percentage >= 90) {
            batteryIcon.classList.add('fa-battery-full', 'battery-full');
          } else if (percentage >= 70) {
            batteryIcon.classList.add('fa-battery-three-quarters', 'battery-good');
          } else if (percentage >= 50) {
            batteryIcon.classList.add('fa-battery-half', 'battery-good');
          } else if (percentage >= 30) {
            batteryIcon.classList.add('fa-battery-quarter', 'battery-medium');
          } else if (percentage >= 10) {
            batteryIcon.classList.add('fa-battery-empty', 'battery-low');
          } else {
            batteryIcon.classList.add('fa-battery-empty', 'battery-low');
          }
        });
      } else {
        batteryPercentage.textContent = 'n/a';
        batteryIcon.className = 'fas fa-battery-slash battery-icon';
      }
    }

    function calculateFPS(): void {
      if (!fpsElement) return;
      frameCount++;
      const now = performance.now();
      const deltaTime = now - lastUpdateTime;

      if (deltaTime >= 1000) {
        const fps = frameCount;
        fpsElement.textContent = `FPS: ${fps}`;
        frameCount = 0;
        lastUpdateTime = now;
      }
      requestAnimationFrame(calculateFPS);
    }

    updateTime();
    updateBattery();
    requestAnimationFrame(calculateFPS);

    setInterval(updateTime, 60000);
    setInterval(updateBattery, 30000);
  });
</script>
